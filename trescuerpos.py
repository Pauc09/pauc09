# -*- coding: utf-8 -*-
"""TresCuerpos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1C-f3DpZjb6cCfqzpwpYv5tH7-SdPIyVN

***Problema de los tres cuerpos***

**Paula Caballero**

**Julian Ricón**
"""

import numpy as np
from IPython.display import Image, display
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from mpl_toolkits.mplot3d import Axes3D
from IPython.display import HTML
!pip install pillow
import matplotlib.animation as animation

"""Simular numéricamente las trayectorias de tres cuerpos reales (Sol, Mercurio y Júpiter) que interactúan gravitacionalmente entre sí usando el método de Runge-Kutta de orden 4 (RK4).

parametros

# **Ejemplo 1**
"""

"""
Simulación del sistema Sol-Mercurio-Júpiter usando el método de Runge-Kutta de 4to orden.

Este código modela el movimiento gravitacional de tres cuerpos celestes: el Sol, Mercurio y Júpiter,
utilizando la ley de gravitación universal de Newton y el método numérico RK4 para la integración.
"""

import numpy as np
import matplotlib.pyplot as plt

# CONSTANTES FÍSICAS
# ------------------------------------------------------------------------------
G = 6.67430e-11  # Constante gravitacional [m^3 kg^-1 s^-2]
AU = 1.496e11    # Unidad Astronómica [metros]

# MASAS DE LOS CUERPOS
# ------------------------------------------------------------------------------
m_sol = 1.989e30      # Masa del Sol [kg]
m_mercurio = 3.285e23  # Masa de Mercurio [kg]
m_jupiter = 1.898e27   # Masa de Júpiter [kg]

# CONDICIONES INICIALES
# ------------------------------------------------------------------------------
# Posiciones iniciales [m] (en el eje Y, con X=0 para simplificar)
r_sol = np.array([0.0, 0.0])                     # Sol en el origen
r_mercurio = np.array([0.0, 0.387 * AU])         # Mercurio a 0.387 AU del Sol
r_jupiter = np.array([0.0, -5.2 * AU])           # Júpiter a 5.2 AU del Sol (lado opuesto)

# Velocidades iniciales [m/s] (en el eje X para movimiento orbital)
v_mercurio = np.array([47890.0, 0.0])            # Velocidad orbital de Mercurio
v_jupiter = np.array([13070.0, 0.0])             # Velocidad orbital de Júpiter

# Ajuste de velocidad del Sol para mantener el centro de masa en reposo
v_sol = -(v_mercurio * m_mercurio + v_jupiter * m_jupiter) / m_sol

# Vector de estado inicial concatenado [pos_sol, vel_sol, pos_mercurio, vel_mercurio, pos_jupiter, vel_jupiter]
y0 = np.concatenate([r_sol, v_sol, r_mercurio, v_mercurio, r_jupiter, v_jupiter])

# FUNCIÓN DERIVADA (ECUACIONES DE MOVIMIENTO)
# ------------------------------------------------------------------------------
def deriv(y, t):
    """
    Calcula las derivadas del sistema (aceleraciones) usando la ley de gravitación de Newton.

    Args:
        y (np.array): Vector de estado actual [posiciones y velocidades]
        t (float): Tiempo actual (no se usa explícitamente, necesario para la interfaz)

    Returns:
        np.array: Vector de derivadas [velocidades y aceleraciones]
    """
    # Extraer posiciones y velocidades para cada cuerpo
    r1, v1 = y[0:2], y[2:4]     # Sol
    r2, v2 = y[4:6], y[6:8]     # Mercurio
    r3, v3 = y[8:10], y[10:12]  # Júpiter

    def a(ri, rj, mj):
        """Calcula la aceleración en ri debido a la masa mj en rj."""
        diff = rj - ri                     # Vector diferencia
        dist = np.linalg.norm(diff)       # Distancia entre cuerpos
        return G * mj * diff / dist**3     # Aceleración gravitacional

    # Aceleraciones para cada cuerpo (suma de contribuciones gravitacionales)
    a1 = a(r1, r2, m_mercurio) + a(r1, r3, m_jupiter)  # Sol
    a2 = a(r2, r1, m_sol) + a(r2, r3, m_jupiter)        # Mercurio
    a3 = a(r3, r1, m_sol) + a(r3, r2, m_mercurio)       # Júpiter

    return np.concatenate([v1, a1, v2, a2, v3, a3])

# MÉTODO NUMÉRICO (RUNGE-KUTTA 4TO ORDEN)
# ------------------------------------------------------------------------------
def rk4_step(f, y, t, dt):
    """
    Realiza un paso de integración usando el método Runge-Kutta de 4to orden.

    Args:
        f (function): Función derivada (y' = f(y,t))
        y (np.array): Vector de estado actual
        t (float): Tiempo actual
        dt (float): Paso de tiempo

    Returns:
        np.array: Nuevo vector de estado después del paso de tiempo
    """
    k1 = f(y, t)
    k2 = f(y + dt * k1 / 2, t + dt / 2)
    k3 = f(y + dt * k2 / 2, t + dt / 2)
    k4 = f(y + dt * k3, t + dt)
    return y + dt * (k1 + 2*k2 + 2*k3 + k4) / 6

# SIMULACIÓN
# ------------------------------------------------------------------------------
def simulate(y0, f, t_max, dt):
    """
    Ejecuta la simulación completa del sistema.

    Args:
        y0 (np.array): Vector de estado inicial
        f (function): Función derivada
        t_max (float): Tiempo total de simulación [s]
        dt (float): Paso de tiempo [s]

    Returns:
        np.array: Matriz con la trayectoria completa de todos los cuerpos
    """
    steps = int(t_max / dt)                          # Número total de pasos
    t_vals = np.linspace(0, t_max, steps)           # Vector de tiempos
    traj = np.zeros((steps, len(y0)))               # Matriz para almacenar trayectorias
    y = y0.copy()                                    # Copia del estado inicial

    for i in range(steps):
        traj[i] = y                                  # Almacenar estado actual
        y = rk4_step(f, y, t_vals[i], dt)          # Avanzar un paso

    return traj

# PARÁMETROS DE SIMULACIÓN
# ------------------------------------------------------------------------------
t_max = 12 * 365.25 * 24 * 3600  # 12 años en segundos (para cubrir órbita de Júpiter)
dt = 24 * 3600                    # Paso de tiempo de 1 día [s]

# EJECUCIÓN DE LA SIMULACIÓN
# ------------------------------------------------------------------------------
print("Iniciando simulación del sistema Sol-Mercurio-Júpiter...")
traj = simulate(y0, deriv, t_max, dt)
print("Simulación completada.")

# PROCESAMIENTO DE RESULTADOS
# ------------------------------------------------------------------------------
# Extraer coordenadas y convertir a Unidades Astronómicas (AU) para mejor visualización
r_sol = traj[:, 0:2] / AU
r_mercurio = traj[:, 4:6] / AU
r_jupiter = traj[:, 8:10] / AU

# VISUALIZACIÓN
# ------------------------------------------------------------------------------
plt.figure(figsize=(10, 10))

# Graficar trayectorias
plt.plot(r_sol[:, 0], r_sol[:, 1], label='Sol', color='orange', linewidth=2)
plt.plot(r_mercurio[:, 0], r_mercurio[:, 1], label='Mercurio', color='gray')
plt.plot(r_jupiter[:, 0], r_jupiter[:, 1], label='Júpiter', color='brown', linewidth=1.5)

# Marcar posiciones iniciales
plt.scatter(r_sol[0, 0], r_sol[0, 1], color='orange', s=100, label='Inicio Sol')
plt.scatter(r_mercurio[0, 0], r_mercurio[0, 1], color='black', s=20, label='Inicio Mercurio')
plt.scatter(r_jupiter[0, 0], r_jupiter[0, 1], color='darkred', s=50, label='Inicio Júpiter')

# Configuración del gráfico
plt.title('Sistema Sol - Mercurio - Júpiter', fontsize=14)
plt.xlabel('Posición x [AU]', fontsize=12)
plt.ylabel('Posición y [AU]', fontsize=12)
plt.grid(True, linestyle='--', alpha=0.5)
plt.axis('equal')  # Misma escala en ambos ejes
plt.legend(fontsize=10, loc='upper right')
plt.tight_layout()

print("Mostrando resultados gráficos...")
plt.show()

"""## Conclusión

En esta simulación del problema de los tres cuerpos nos enfocamos en el caso simplificado donde solo hay dos cuerpos (Mercurio y Júpiter) orbitan al Sol bajo la influencia gravitacional mutua. La gráfica muestra cómo ambos planetas siguen trayectorias elípticas suaves y bien definidas alrededor del Sol, de acuerdo con las leyes de Kepler.

Podemos notar que las órbitas son elípticas, y aunque visualmente parecen casi perfectas, esto es consecuencia de las condiciones iniciales y del corto período simulado (un año).

Aunque Júpiter tiene una masa muy grande comparada con otros planetas, su efecto gravitacional sobre el Sol no es evidente a simple vista en la gráfica. Esto se debe a que la masa del Sol sigue siendo muy superior, y además, el centro de masa del sistema permanece cercano al centro solar. Aun así, a escalas astronómicas y en simulaciones más precisas o de mayor duración, sí se puede observar cómo el Sol "tambalea" ligeramente por la influencia de Júpiter, fenómeno conocido como movimiento del baricentro.

También es interesante resaltar que, debido a la naturaleza cíclica del sistema, los planetas tienden a alinearse en ciertas configuraciones a lo largo del tiempo. Esto significa que en algunos puntos de sus órbitas, Mercurio y Júpiter estarán relativamente cerca uno del otro en su paso por el mismo lado del Sol. Estas alineaciones pueden repetirse periódicamente, aunque sus frecuencias y posiciones no siempre coincidan exactamente, ya que cada planeta tiene su propio período orbital.

# **Ejemplo 2**
"""

# Parámetros físicos y de simulación
G = 6.67e-11
h = 20000
N = 3000  # Aumentamos pasos para mejor resolución

# Condiciones iniciales
x = (0, -400e9, 150e9, 206e9)
y = (0, 160e9, 0, 0)
vx = (0, 4000, 0, 0)
vy = (-2000, 0, 30000, 24000)
m = (2e30, 2e14, 6e24, 6e23)

# Funciones para integración numérica
def aceleracion(i, j, x, y):
    rij = (x[i] - x[j])**2 + (y[i] - y[j])**2
    ax = -G * m[i] * (x[j] - x[i]) / rij**(3/2)
    ay = -G * m[i] * (y[j] - y[i]) / rij**(3/2)
    return ax, ay

def Fk(k, x, y, vx, vy):
    akx, aky = 0, 0
    for i in range(len(x)):
        if i != k:
            ax, ay = aceleracion(i, k, x, y)
            akx += ax
            aky += ay
    return np.array([vx[k], vy[k], akx, aky])

def siguiente_valor(x, y, vx, vy):
    k1 = [h * Fk(k, x, y, vx, vy) for k in range(len(m))]
    x1 = tuple(x[i] + k1[i][0] / 2 for i in range(len(m)))
    y1 = tuple(y[i] + k1[i][1] / 2 for i in range(len(m)))
    vx1 = tuple(vx[i] + k1[i][2] / 2 for i in range(len(m)))
    vy1 = tuple(vy[i] + k1[i][3] / 2 for i in range(len(m)))

    k2 = [h * Fk(k, x1, y1, vx1, vy1) for k in range(len(m))]
    x2 = tuple(x[i] + k2[i][0] / 2 for i in range(len(m)))
    y2 = tuple(y[i] + k2[i][1] / 2 for i in range(len(m)))
    vx2 = tuple(vx[i] + k2[i][2] / 2 for i in range(len(m)))
    vy2 = tuple(vy[i] + k2[i][3] / 2 for i in range(len(m)))

    k3 = [h * Fk(k, x2, y2, vx2, vy2) for k in range(len(m))]
    x3 = tuple(x[i] + k3[i][0] for i in range(len(m)))
    y3 = tuple(y[i] + k3[i][1] for i in range(len(m)))
    vx3 = tuple(vx[i] + k3[i][2] for i in range(len(m)))
    vy3 = tuple(vy[i] + k3[i][3] for i in range(len(m)))

    k4 = [h * Fk(k, x3, y3, vx3, vy3) for k in range(len(m))]

    xf = tuple(x[i] + (k1[i][0] + 2 * k2[i][0] + 2 * k3[i][0] + k4[i][0]) / 6 for i in range(len(m)))
    yf = tuple(y[i] + (k1[i][1] + 2 * k2[i][1] + 2 * k3[i][1] + k4[i][1]) / 6 for i in range(len(m)))
    vxf = tuple(vx[i] + (k1[i][2] + 2 * k2[i][2] + 2 * k3[i][2] + k4[i][2]) / 6 for i in range(len(m)))
    vyf = tuple(vy[i] + (k1[i][3] + 2 * k2[i][3] + 2 * k3[i][3] + k4[i][3]) / 6 for i in range(len(m)))

    return xf, yf, vxf, vyf

# Simulación
X, Y, Vx, Vy = [x], [y], [vx], [vy]
for t in range(N):
    sig = siguiente_valor(X[-1], Y[-1], Vx[-1], Vy[-1])
    X.append(sig[0])
    Y.append(sig[1])
    Vx.append(sig[2])
    Vy.append(sig[3])

X = np.array(X)
Y = np.array(Y)

# Crear animación
fig, ax = plt.subplots(figsize=(8, 6))

def actualizar(i):
    ax.clear()

    # Fases:
    # 0 - 33% → cuerpos 0 y 1
    # 34% - 66% → + cuerpo 2
    # 67%+ → todos

    fase1 = int(N * 0.33)
    fase2 = int(N * 0.66)

    if i < fase1:
        cuerpos = [0, 1]
    elif i < fase2:
        cuerpos = [0, 1, 2]
    else:
        cuerpos = [0, 1, 2, 3]

    for t in cuerpos:
        x = X[:, t] - X[:, 0]  # movimiento relativo a la estrella
        y = Y[:, t] - Y[:, 0]
        if t == 0:
            ax.plot(x[:i], y[:i], '-', label='Estrella')
            ax.plot(x[i], y[i], 'o', color='yellow', markersize=10)
        elif t == 1:
            ax.plot(x[:i], y[:i], '--', label='Cometa')
            ax.plot(x[i], y[i], '*', color='cyan', markersize=8)
        else:
            ax.plot(x[:i], y[:i], '-', label=f'Planeta {t-1}')
            ax.plot(x[i], y[i], 'o', color='blue', markersize=6)

    ax.set_xlim(-3e11, 3e11)
    ax.set_ylim(-8e11, 3e11)
    ax.set_title("Problema de los Tres Cuerpos - Animación por Fases")
    ax.set_xlabel("X (m)")
    ax.set_ylabel("Y (m)")
    ax.legend()
    ax.grid()

# Crear animación más lenta (interval=100ms = 10 fps)
ani = animation.FuncAnimation(fig, actualizar, frames=range(0, N, 25), interval=100)

# Guardar como GIF
ani.save("tres_cuerpos_fases.gif", writer="pillow")

# Cerrar la figura para que no se muestre estática
plt.close(fig)

# Mostrar GIF
display(Image(filename="tres_cuerpos_fases.gif"))

"""**Conclusión**

En esta simulación del problema de los tres cuerpos, hemos agregado un tercer objeto al sistema: un cometa. A diferencia del sistema anterior, que mostraba órbitas estables y predecibles para dos planetas (Mercurio y Júpiter) alrededor del Sol, la introducción de un tercer cuerpo cambia el panorama.

En este caso, el cometa sigue una trayectoria propia, determinada principalmente por la gravedad del Sol, ya que es el cuerpo con mayor masa en el sistema. Aunque el cometa interactúa gravitacionalmente con los otros planetas, su influencia sobre ellos es prácticamente despreciable debido a su que masa es menor. Por eso, en la simulación, las órbitas de Mercurio y Júpiter no se deforman visiblemente.

Lo interesante del problema de los tres cuerpos es que, en teoría, cuando los tres cuerpos tienen masas comparables y se atraen mutuamente, el sistema puede volverse altamente caótico y difícil de predecir a largo plazo. Sin embargo, en este caso particular, el cometa actúa más como un "cuerpo de prueba": responde a las fuerzas de los otros dos, pero no las altera significativamente. Por eso su órbita parece estable, y no perturba el equilibrio del sistema planetario.

Además, es importante notar que si el cometa tuviera una masa mayor, o si su trayectoria lo llevara cerca de uno de los planetas en el momento adecuado, sí podría introducir perturbaciones que alteren sus órbitas.

# **Tres cuerpos**
"""

"""
Simulación del problema de N-cuerpos con animación por fases

Este código simula un sistema gravitacional de múltiples cuerpos usando el método
Runge-Kutta de 4to orden y crea una animación que muestra el sistema en fases:
1. Primero solo dos cuerpos (estrella y cometa)
2. Luego tres cuerpos (agregando un planeta)
3. Finalmente cuatro cuerpos (agregando otro planeta)
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from IPython.display import Image, display

# =============================================================================
# PARÁMETROS FÍSICOS Y DE SIMULACIÓN
# =============================================================================
G = 6.67e-11    # Constante gravitacional [m^3 kg^-1 s^-2]
h = 20000       # Paso de tiempo para la integración [s]
N = 5000        # Número total de pasos de simulación

# =============================================================================
# CONDICIONES INICIALES
# =============================================================================
# Posiciones iniciales de los cuerpos [m]
# Formato: (x0, x1, x2, x3) para los 4 cuerpos
x = (0, 100e9, -100e9, 0)    # Coordenadas x iniciales
y = (0, 0, 0, 100e9)         # Coordenadas y iniciales

# Velocidades iniciales [m/s]
vx = (0, 0, 0, -15000)       # Velocidades en x
vy = (0, 25000, -25000, 0)   # Velocidades en y

# Masas de los cuerpos [kg]
m = (2e30, 1e28, 1e28, 1e28)  # masa[0] = estrella, masas[1-3] = otros cuerpos

# =============================================================================
# FUNCIONES PARA INTEGRACIÓN NUMÉRICA (RUNGE-KUTTA 4TO ORDEN)
# =============================================================================
def aceleracion(i, j, x, y):
    """
    Calcula la aceleración gravitacional del cuerpo i debido al cuerpo j.

    Args:
        i (int): Índice del cuerpo que experimenta la aceleración
        j (int): Índice del cuerpo que causa la aceleración
        x (tuple): Tupla con las posiciones x de todos los cuerpos
        y (tuple): Tupla con las posiciones y de todos los cuerpos

    Returns:
        tuple: Componentes (ax, ay) de la aceleración gravitacional
    """
    # Distancia al cuadrado entre los cuerpos i y j
    rij = (x[i] - x[j])**2 + (y[i] - y[j])**2

    # Componentes de la aceleración según la ley de gravitación universal
    ax = -G * m[i] * (x[j] - x[i]) / rij**(3/2)
    ay = -G * m[i] * (y[j] - y[i]) / rij**(3/2)

    return ax, ay

def Fk(k, x, y, vx, vy):
    """
    Calcula las derivadas para el cuerpo k (velocidades y aceleraciones).

    Args:
        k (int): Índice del cuerpo actual
        x (tuple): Posiciones x actuales
        y (tuple): Posiciones y actuales
        vx (tuple): Velocidades x actuales
        vy (tuple): Velocidades y actuales

    Returns:
        np.array: Vector [vx_k, vy_k, ax_k, ay_k] para el cuerpo k
    """
    akx, aky = 0, 0  # Inicializar aceleraciones

    # Sumar contribuciones gravitacionales de todos los otros cuerpos
    for i in range(len(x)):
        if i != k:
            ax, ay = aceleracion(i, k, x, y)
            akx += ax
            aky += ay

    return np.array([vx[k], vy[k], akx, aky])

def siguiente_valor(x, y, vx, vy):
    """
    Realiza un paso de integración usando el método Runge-Kutta 4.

    Args:
        x (tuple): Posiciones x actuales
        y (tuple): Posiciones y actuales
        vx (tuple): Velocidades x actuales
        vy (tuple): Velocidades y actuales

    Returns:
        tuple: Nuevas posiciones y velocidades (x, y, vx, vy)
    """
    # Paso 1 de Runge-Kutta
    k1 = [h * Fk(k, x, y, vx, vy) for k in range(len(m))]
    x1 = tuple(x[i] + k1[i][0] / 2 for i in range(len(m)))
    y1 = tuple(y[i] + k1[i][1] / 2 for i in range(len(m)))
    vx1 = tuple(vx[i] + k1[i][2] / 2 for i in range(len(m)))
    vy1 = tuple(vy[i] + k1[i][3] / 2 for i in range(len(m)))

    # Paso 2 de Runge-Kutta
    k2 = [h * Fk(k, x1, y1, vx1, vy1) for k in range(len(m))]
    x2 = tuple(x[i] + k2[i][0] / 2 for i in range(len(m)))
    y2 = tuple(y[i] + k2[i][1] / 2 for i in range(len(m)))
    vx2 = tuple(vx[i] + k2[i][2] / 2 for i in range(len(m)))
    vy2 = tuple(vy[i] + k2[i][3] / 2 for i in range(len(m)))

    # Paso 3 de Runge-Kutta
    k3 = [h * Fk(k, x2, y2, vx2, vy2) for k in range(len(m))]
    x3 = tuple(x[i] + k3[i][0] for i in range(len(m)))
    y3 = tuple(y[i] + k3[i][1] for i in range(len(m)))
    vx3 = tuple(vx[i] + k3[i][2] for i in range(len(m)))
    vy3 = tuple(vy[i] + k3[i][3] for i in range(len(m)))

    # Paso 4 de Runge-Kutta
    k4 = [h * Fk(k, x3, y3, vx3, vy3) for k in range(len(m))]

    # Combinación de los pasos para obtener el valor final
    xf = tuple(x[i] + (k1[i][0] + 2*k2[i][0] + 2*k3[i][0] + k4[i][0])/6 for i in range(len(m)))
    yf = tuple(y[i] + (k1[i][1] + 2*k2[i][1] + 2*k3[i][1] + k4[i][1])/6 for i in range(len(m)))
    vxf = tuple(vx[i] + (k1[i][2] + 2*k2[i][2] + 2*k3[i][2] + k4[i][2])/6 for i in range(len(m)))
    vyf = tuple(vy[i] + (k1[i][3] + 2*k2[i][3] + 2*k3[i][3] + k4[i][3])/6 for i in range(len(m)))

    return xf, yf, vxf, vyf

# =============================================================================
# SIMULACIÓN PRINCIPAL
# =============================================================================
# Almacenar historial de posiciones y velocidades
X, Y, Vx, Vy = [x], [y], [vx], [vy]

print("Iniciando simulación...")
for t in range(N):
    # Calcular siguiente paso
    sig = siguiente_valor(X[-1], Y[-1], Vx[-1], Vy[-1])

    # Almacenar resultados
    X.append(sig[0])
    Y.append(sig[1])
    Vx.append(sig[2])
    Vy.append(sig[3])

# Convertir a arrays de numpy para manipulación más fácil
X = np.array(X)
Y = np.array(Y)
print("Simulación completada.")

# =============================================================================
# ANIMACIÓN
# =============================================================================
print("Preparando animación...")
fig, ax = plt.subplots(figsize=(8, 6))

def actualizar(i):
    """Función que actualiza la animación para el frame i."""
    ax.clear()

    # Definir fases de la animación
    fase1 = int(N * 0.33)  # Primera fase: 33% de la simulación
    fase2 = int(N * 0.66)  # Segunda fase: 66% de la simulación

    # Determinar qué cuerpos mostrar según la fase actual
    if i < fase1:
        cuerpos = [0, 1]  # Solo estrella y cometa
    elif i < fase2:
        cuerpos = [0, 1, 2]  # Agregar primer planeta
    else:
        cuerpos = [0, 1, 2, 3]  # Mostrar todos los cuerpos

    # Graficar cada cuerpo
    for t in cuerpos:
        # Posición relativa a la estrella (cuerpo 0)
        x_rel = X[:, t] - X[:, 0]
        y_rel = Y[:, t] - Y[:, 0]

        # Configuración de estilo según el tipo de cuerpo
        if t == 0:  # Estrella
            ax.plot(x_rel[:i], y_rel[:i], '-', label='Estrella')
            ax.plot(x_rel[i], y_rel[i], 'o', color='yellow', markersize=10)
        elif t == 1:  # Cometa
            ax.plot(x_rel[:i], y_rel[:i], '--', label='Cometa')
            ax.plot(x_rel[i], y_rel[i], '*', color='cyan', markersize=8)
        else:  # Planetas
            ax.plot(x_rel[:i], y_rel[:i], '-', label=f'Planeta {t-1}')
            ax.plot(x_rel[i], y_rel[i], 'o', color='blue', markersize=6)

    # Configuración del gráfico
    ax.set_xlim(-3e11, 3e11)
    ax.set_ylim(-8e11, 3e11)
    ax.set_title("Problema de los Tres Cuerpos - Animación por Fases")
    ax.set_xlabel("Posición X (m)")
    ax.set_ylabel("Posición Y (m)")
    ax.legend()
    ax.grid()

# Crear animación (mostrando 1 de cada 25 frames a 10 fps)
ani = animation.FuncAnimation(
    fig,
    actualizar,
    frames=range(0, N, 25),  # Saltos para hacer animación más rápida
    interval=100  # 100ms entre frames = 10 fps
)

# Guardar como GIF
print("Guardando animación como GIF...")
ani.save("tres_cuerpos_fases.gif", writer="pillow")
plt.close(fig)  # Cerrar figura para evitar duplicados

# Mostrar GIF resultante
print("Mostrando animación:")
display(Image(filename="tres_cuerpos_fases.gif"))

"""En esta simulación, a diferencia del caso anterior, el cometa sí afecta visiblemente las órbitas de los otros planetas. Esto se debe principalmente a que aumentamos su masa, haciéndola comparable a la de los otros cuerpos del sistema. En el contexto del problema de los tres cuerpos, esto es fundamental: cuando los tres objetos tienen masas significativas, la fuerza gravitacional entre ellos es mutua y considerable, lo que genera una interacción mucho más compleja.

Como resultado, ya no se observan órbitas limpias ni elípticas como en el caso de solo dos cuerpos. En cambio, vemos que las trayectorias se deforman, cambian de dirección y, en algunos casos, incluso parecen caóticas.
"""